!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
BELE	harness.c	/^typedef struct BELE {$/;"	s	file:
BIG_QUEUE	qtest.c	34;"	d	file:
BUFSIZE	qtest.c	492;"	d	file:
CC	Makefile	/^CC = gcc$/;"	m
CELE	console.h	/^struct CELE {$/;"	s
CFLAGS	Makefile	/^CFLAGS = -O0 -g -Wall -Werror$/;"	m
ELE	queue.h	/^typedef struct ELE {$/;"	s
FILLCHAR	harness.c	25;"	d	file:
INTERNAL	harness.c	13;"	d	file:
INTERNAL	qtest.c	10;"	d	file:
MAGICFOOTER	harness.c	23;"	d	file:
MAGICFREE	harness.c	21;"	d	file:
MAGICHEADER	harness.c	19;"	d	file:
MAX	report.c	15;"	d	file:
MAXQUIT	console.c	67;"	d	file:
MAXSTRING	qtest.c	14;"	d	file:
MAX_CHAR	report.h	15;"	d
MSG_ERROR	report.h	/^typedef enum { MSG_WARN, MSG_ERROR, MSG_FATAL } message_t;$/;"	e	enum:__anon2
MSG_FATAL	report.h	/^typedef enum { MSG_WARN, MSG_ERROR, MSG_FATAL } message_t;$/;"	e	enum:__anon2
MSG_WARN	report.h	/^typedef enum { MSG_WARN, MSG_ERROR, MSG_FATAL } message_t;$/;"	e	enum:__anon2
PELE	console.h	/^struct PELE {$/;"	s
RIO_BUFSIZE	console.c	38;"	d	file:
RIO_ELE	console.c	/^struct RIO_ELE {$/;"	s	file:
RPT	report.h	6;"	d
STRINGPAD	qtest.c	16;"	d	file:
Tracer	driver.py	/^class Tracer:$/;"	c
__init__	driver.py	/^    def __init__(self, qtest = "", verbLevel = 0, autograde = False):$/;"	m	class:Tracer
add_cmd	console.c	/^void add_cmd(char *name, cmd_function operation, char *documentation) {$/;"	f
add_param	console.c	/^void add_param(char *name, int *valp, char *documentation,$/;"	f
add_quit_helper	console.c	/^void add_quit_helper(cmd_function qf) {$/;"	f
allocate_bytes	report.c	/^static size_t allocate_bytes = 0;$/;"	v	file:
allocate_cnt	report.c	/^static size_t allocate_cnt = 0;$/;"	v	file:
allocated	harness.c	/^static block_ele_t *allocated = NULL;$/;"	v	file:
allocated_count	harness.c	/^static size_t allocated_count = 0;$/;"	v	file:
allocation_check	harness.c	/^size_t allocation_check() {$/;"	f
autograde	driver.py	/^    autograde = False$/;"	v	class:Tracer
big_queue_size	qtest.c	/^int big_queue_size = BIG_QUEUE;$/;"	v
block_console	console.c	/^void block_console() {$/;"	f
block_ele_t	harness.c	/^} block_ele_t;$/;"	t	typeref:struct:BELE	file:
block_flag	console.c	/^static bool block_flag = false;$/;"	v	file:
block_timing	console.c	/^static bool block_timing = false;$/;"	v	file:
buf	console.c	/^    char buf[RIO_BUFSIZE]; \/* Internal buffer *\/$/;"	m	struct:RIO_ELE	file:
buf_stack	console.c	/^rio_ptr buf_stack;$/;"	v
bufptr	console.c	/^    char *bufptr;          \/* Next unread byte in internal buffer *\/$/;"	m	struct:RIO_ELE	file:
calloc_or_fail	report.c	/^void *calloc_or_fail(size_t cnt, size_t bytes, char *fun_name) {$/;"	f
cautious_mode	harness.c	/^static bool cautious_mode = true;$/;"	v	file:
check_exceed	report.c	/^static void check_exceed(size_t new_bytes) {$/;"	f	file:
cmd_done	console.c	/^bool cmd_done() {$/;"	f
cmd_ele	console.h	/^typedef struct CELE cmd_ele, *cmd_ptr;$/;"	t	typeref:struct:CELE
cmd_function	console.h	/^typedef bool (*cmd_function)(int argc, char *argv[]);$/;"	t
cmd_list	console.c	/^static cmd_ptr cmd_list = NULL;$/;"	v	file:
cmd_ptr	console.h	/^typedef struct CELE cmd_ele, *cmd_ptr;$/;"	t	typeref:struct:
cmd_select	console.c	/^int cmd_select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds,$/;"	f
cnt	console.c	/^    int cnt;               \/* Unread bytes in internal buffer *\/$/;"	m	struct:RIO_ELE	file:
console_init	qtest.c	/^static void console_init() {$/;"	f	file:
current_bytes	report.c	/^size_t current_bytes = 0;$/;"	v
current_bytes	report.h	/^size_t current_bytes;$/;"	v
default_fatal_fun	report.c	/^void default_fatal_fun() {$/;"	f
delta_time	report.c	/^double delta_time(double *timep) {$/;"	f
do_comment_cmd	console.c	/^bool do_comment_cmd(int argc, char *argv[]) {$/;"	f
do_free	qtest.c	/^bool do_free(int argc, char *argv[])$/;"	f
do_help_cmd	console.c	/^bool do_help_cmd(int argc, char *argv[]) {$/;"	f
do_insert_head	qtest.c	/^bool do_insert_head(int argc, char *argv[])$/;"	f
do_insert_tail	qtest.c	/^bool do_insert_tail(int argc, char *argv[])$/;"	f
do_log_cmd	console.c	/^bool do_log_cmd(int argc, char *argv[]) {$/;"	f
do_new	qtest.c	/^bool do_new(int argc, char *argv[])$/;"	f
do_option_cmd	console.c	/^bool do_option_cmd(int argc, char *argv[]) {$/;"	f
do_quit_cmd	console.c	/^bool do_quit_cmd(int argc, char *argv[]) {$/;"	f
do_remove_head	qtest.c	/^bool do_remove_head(int argc, char *argv[])$/;"	f
do_remove_head_quiet	qtest.c	/^bool do_remove_head_quiet(int argc, char *argv[])$/;"	f
do_reverse	qtest.c	/^bool do_reverse(int argc, char *argv[])$/;"	f
do_show	qtest.c	/^bool do_show(int argc, char *argv[])$/;"	f
do_size	qtest.c	/^bool do_size(int argc, char *argv[])$/;"	f
do_source_cmd	console.c	/^bool do_source_cmd(int argc, char *argv[]) {$/;"	f
do_time_cmd	console.c	/^bool do_time_cmd(int argc, char *argv[]) {$/;"	f
documentation	console.h	/^    char *documentation;$/;"	m	struct:CELE
documentation	console.h	/^    char *documentation;$/;"	m	struct:PELE
echo	console.c	/^static int echo = 0;$/;"	v	file:
end	queue.h	/^    list_ele_t *end;$/;"	m	struct:__anon1
env	harness.c	/^static jmp_buf env;$/;"	v	file:
err_cnt	console.c	/^static int err_cnt = 0;$/;"	v	file:
err_limit	console.c	/^static int err_limit = 5;$/;"	v	file:
errfile	report.c	/^FILE *errfile = NULL;$/;"	v
error_check	harness.c	/^bool error_check() {$/;"	f
error_message	harness.c	/^static char *error_message = "";$/;"	v	file:
error_occurred	harness.c	/^static bool error_occurred = false;$/;"	v	file:
exception_cancel	harness.c	/^void exception_cancel() {$/;"	f
exception_setup	harness.c	/^bool exception_setup(bool limit_time) {$/;"	f
fail_allocation	harness.c	/^static bool fail_allocation() {$/;"	f	file:
fail_buf	report.c	/^static char fail_buf[1024] = "FATAL Error.  Exiting\\n";$/;"	v	file:
fail_count	qtest.c	/^int fail_count = 0;$/;"	v
fail_fun	report.c	/^void fail_fun(char *format, char *msg) {$/;"	f
fail_limit	qtest.c	/^int fail_limit = BIG_QUEUE;$/;"	v
fail_probability	harness.c	/^int fail_probability = 0;$/;"	v
fail_probability	harness.h	/^int fail_probability;$/;"	v
fatal_fun	report.c	/^void (*fatal_fun)() = default_fatal_fun;$/;"	v
fd	console.c	/^    int fd;                \/* File descriptor *\/$/;"	m	struct:RIO_ELE	file:
fd_max	console.c	/^int fd_max = 0;$/;"	v
find_footer	harness.c	/^static size_t *find_footer(block_ele_t *b) {$/;"	f	file:
find_header	harness.c	/^static block_ele_t *find_header(void *p) {$/;"	f	file:
finish_cmd	console.c	/^bool finish_cmd() {$/;"	f
first_time	console.c	/^static double first_time;$/;"	v	file:
free	harness.h	59;"	d
free_array	report.c	/^void free_array(void *b, size_t cnt, size_t bytes) {$/;"	f
free_block	report.c	/^void free_block(void *b, size_t bytes) {$/;"	f
free_bytes	report.c	/^static size_t free_bytes = 0;$/;"	v	file:
free_cnt	report.c	/^static size_t free_cnt = 0;$/;"	v	file:
free_string	report.c	/^void free_string(char *s) {$/;"	f
get_int	console.c	/^bool get_int(char *vname, int *loc) {$/;"	f
gigabytes	report.c	/^double gigabytes(size_t n) {$/;"	f
head	queue.h	/^    list_ele_t *head;  \/* Linked list of elements *\/$/;"	m	struct:__anon1
init_cmd	console.c	/^void init_cmd() {$/;"	f
init_files	report.c	/^void init_files(FILE *efile, FILE *vfile)$/;"	f
init_in	console.c	/^static void init_in() {$/;"	f	file:
init_time	report.c	/^void init_time(double *timep) {$/;"	f
interpret_cmd	console.c	/^bool interpret_cmd(char *cmdline) {$/;"	f
interpret_cmda	console.c	/^static bool interpret_cmda(int argc, char *argv[]) {$/;"	f	file:
jmp_ready	harness.c	/^static volatile sig_atomic_t jmp_ready = false;$/;"	v	file:
last_peak_bytes	report.c	/^size_t last_peak_bytes = 0;$/;"	v
last_peak_bytes	report.h	/^size_t last_peak_bytes;$/;"	v
last_time	console.c	/^static double last_time;$/;"	v	file:
linebuf	console.c	/^char linebuf[RIO_BUFSIZE];$/;"	v
list_ele_t	queue.h	/^} list_ele_t;$/;"	t	typeref:struct:ELE
logfile	report.c	/^FILE *logfile = NULL;$/;"	v
magic_header	harness.c	/^    size_t magic_header; \/* Marker to see if block seems legitimate *\/$/;"	m	struct:BELE	file:
main	qtest.c	/^int main(int argc, char *argv[]) {$/;"	f
malloc	harness.h	58;"	d
malloc_or_fail	report.c	/^void * malloc_or_fail(size_t bytes, char *fun_name) {$/;"	f
maxScores	driver.py	/^    maxScores = [0, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7]$/;"	v	class:Tracer
mblimit	report.c	/^int mblimit = 0;$/;"	v
mem_status	report.c	/^void mem_status(FILE *fp) {$/;"	f
message_t	report.h	/^typedef enum { MSG_WARN, MSG_ERROR, MSG_FATAL } message_t;$/;"	t	typeref:enum:__anon2
name	console.h	/^    char *name;$/;"	m	struct:CELE
name	console.h	/^    char *name;$/;"	m	struct:PELE
next	console.h	/^    cmd_ptr next;$/;"	m	struct:CELE
next	console.h	/^    param_ptr next;$/;"	m	struct:PELE
next	harness.c	/^    struct BELE *next;$/;"	m	struct:BELE	typeref:struct:BELE::BELE	file:
next	queue.h	/^    struct ELE *next;$/;"	m	struct:ELE	typeref:struct:ELE::ELE
noallocate_mode	harness.c	/^static bool noallocate_mode = false;$/;"	v	file:
operation	console.h	/^    cmd_function operation;$/;"	m	struct:CELE
param_ele	console.h	/^typedef struct PELE param_ele, *param_ptr;$/;"	t	typeref:struct:PELE
param_list	console.c	/^static param_ptr param_list = NULL;$/;"	v	file:
param_ptr	console.h	/^typedef struct PELE param_ele, *param_ptr;$/;"	t	typeref:struct:
parse_args	console.c	/^char **parse_args(char *line, int *argcp) {$/;"	f
payload	harness.c	/^    unsigned char payload[0];$/;"	m	struct:BELE	file:
payload_size	harness.c	/^    size_t payload_size;$/;"	m	struct:BELE	file:
peak_bytes	report.c	/^size_t peak_bytes = 0;$/;"	v
peak_bytes	report.h	/^size_t peak_bytes;$/;"	v
pop_file	console.c	/^static void pop_file() {$/;"	f	file:
prev	console.c	/^    rio_ptr prev;          \/* Next element in stack *\/$/;"	m	struct:RIO_ELE	file:
prev	harness.c	/^    struct BELE *prev;$/;"	m	struct:BELE	typeref:struct:BELE::BELE	file:
prompt	console.c	/^static char *prompt = "cmd>";$/;"	v	file:
prompt_flag	console.c	/^static bool prompt_flag = true;$/;"	v	file:
push_file	console.c	/^static bool push_file(char *fname) {$/;"	f	file:
q	qtest.c	/^queue_t *q = NULL;$/;"	v
q_free	queue.c	/^void q_free(queue_t *q)$/;"	f
q_insert_head	queue.c	/^bool q_insert_head(queue_t *q, char *s)$/;"	f
q_insert_tail	queue.c	/^bool q_insert_tail(queue_t *q, char *s)$/;"	f
q_new	queue.c	/^queue_t *q_new()$/;"	f
q_remove_head	queue.c	/^bool q_remove_head(queue_t *q, char *sp, size_t bufsize)$/;"	f
q_reverse	queue.c	/^void q_reverse(queue_t *q)$/;"	f
q_size	queue.c	/^int q_size(queue_t *q)$/;"	f
qcnt	qtest.c	/^size_t qcnt = 0;$/;"	v
qtest	driver.py	/^    qtest = ".\/qtest"$/;"	v	class:Tracer
queue_init	qtest.c	/^static void queue_init() {$/;"	f	file:
queue_quit	qtest.c	/^static bool queue_quit(int argc, char *argv[]) {$/;"	f	file:
queue_t	queue.h	/^} queue_t;$/;"	t	typeref:struct:__anon1
quit_flag	console.c	/^static bool quit_flag = false;$/;"	v	file:
quit_helper_cnt	console.c	/^static int quit_helper_cnt = 0;$/;"	v	file:
quit_helpers	console.c	/^static cmd_function quit_helpers[MAXQUIT];$/;"	v	file:
read_ready	console.c	/^static bool read_ready() {$/;"	f	file:
readline	console.c	/^static char *readline() {$/;"	f	file:
realloc_or_fail	report.c	/^void * realloc_or_fail(void *old, size_t old_bytes, size_t new_bytes,$/;"	f
record_error	console.c	/^void record_error() {$/;"	f
report	report.c	/^void report(int level, char *fmt, ...)$/;"	f
report_event	report.c	/^void report_event(message_t msg, char *fmt, ...)$/;"	f
report_noreturn	report.c	/^void report_noreturn(int level, char *fmt, ...)$/;"	f
reset_peak_bytes	report.c	/^void reset_peak_bytes() {$/;"	f
resident_bytes	report.c	/^size_t resident_bytes() {$/;"	f
rio_ptr	console.c	/^typedef struct RIO_ELE rio_t, *rio_ptr;$/;"	t	typeref:struct:	file:
rio_t	console.c	/^typedef struct RIO_ELE rio_t, *rio_ptr;$/;"	t	typeref:struct:RIO_ELE	file:
run	driver.py	/^    def run(self, tid = 0):$/;"	m	class:Tracer
run	driver.py	/^def run(name, args):$/;"	f
runTrace	driver.py	/^    def runTrace(self, tid):$/;"	m	class:Tracer
run_console	console.c	/^bool run_console(char *infile_name) {$/;"	f
rval	report.c	/^volatile int rval = 0;$/;"	v
safe_report	report.c	/^void safe_report(int level, char *msg)$/;"	f
set_cautious_mode	harness.c	/^void set_cautious_mode(bool cautious)$/;"	f
set_echo	console.c	/^void set_echo(bool on) {$/;"	f
set_logfile	report.c	/^bool set_logfile(char *file_name)$/;"	f
set_noallocate_mode	harness.c	/^void set_noallocate_mode(bool noallocate)$/;"	f
set_prompt	console.c	/^void set_prompt(char *p) {$/;"	f
set_verblevel	report.c	/^void set_verblevel(int level)$/;"	f
setter	console.h	/^    setter_function setter;$/;"	m	struct:PELE
setter_function	console.h	/^typedef void (*setter_function)(int oldval);$/;"	t
show_queue	qtest.c	/^static bool show_queue(int vlevel)$/;"	f	file:
sigalrmhandler	qtest.c	/^void sigalrmhandler(int sig) {$/;"	f
sigsegvhandler	qtest.c	/^void sigsegvhandler(int sig) {$/;"	f
size	queue.h	/^    int size;$/;"	m	struct:__anon1
start_cmd	console.c	/^bool start_cmd(char *infile_name) {$/;"	f
string_length	qtest.c	/^int string_length = MAXSTRING;$/;"	v
strsave_or_fail	report.c	/^char *strsave_or_fail(char *s, char *fun_name) {$/;"	f
test_free	harness.c	/^void test_free(void *p)$/;"	f
test_malloc	harness.c	/^void *test_malloc(size_t size)$/;"	f
time_limit	harness.c	/^static int time_limit = 1;$/;"	v	file:
time_limited	harness.c	/^static bool time_limited = false;$/;"	v	file:
timelimit	report.c	/^int timelimit = 0;$/;"	v
traceDict	driver.py	/^    traceDict = {$/;"	v	class:Tracer
traceDirectory	driver.py	/^    traceDirectory = ".\/traces"$/;"	v	class:Tracer
traceProbs	driver.py	/^    traceProbs = {$/;"	v	class:Tracer
trigger_exception	harness.c	/^void trigger_exception(char *msg) {$/;"	f
unblock_console	console.c	/^void unblock_console() {$/;"	f
usage	driver.py	/^def usage(name):$/;"	f
usage	qtest.c	/^static void usage(char *cmd) {$/;"	f	file:
valp	console.h	/^    int *valp;$/;"	m	struct:PELE
value	queue.h	/^    char *value;$/;"	m	struct:ELE
verbLevel	driver.py	/^    verbLevel = 0$/;"	v	class:Tracer
verbfile	report.c	/^FILE *verbfile = NULL;$/;"	v
verblevel	report.c	/^int verblevel = 0;$/;"	v
